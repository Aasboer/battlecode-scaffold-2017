// This is the build file we use to compile and run Battlecode players.
// We're using Gradle: https://gradle.org/

// Gradle's plugins allow it to automatically generate build scripts
// for different types of code. Here we apply the 'java' plugin, which provide
// all the tools needed to build player code!
apply plugin: 'java'
//apply plugin: 'scala'
//apply plugin: 'kotlin'

// These plugins allow for this build script to be compatible with IDEs.
apply plugin: 'idea'
apply plugin: 'eclipse'

sourceCompatibility = 1.8

// We override Gradle's defaults for project directory layout.
sourceSets {
    main {
        java.srcDirs = ["src"]
        output.classesDir = "$buildDir/src"
    }

    test {
        java.srcDirs = ["test"]
        output.classesDir = "$buildDir/tests"
    }
}

repositories {
    // Let Gradle know about our own repository for hosting Battlecode.
    maven {
        url "http://battlecode-maven-test-aaarblgarbl.s3-website-us-east-1.amazonaws.com/"
    }
}

// Mark the client as a special dependency, so that we can handle it separately.
configurations {
    client
}

// Download a different version of the client depending on the local OS.
def os = System.getProperty("os.name").toLowerCase()
def clientName = os.startsWith('windows') ? 'battlecode-client-win' :
                 os.startsWith('mac') ? 'battlecode-client-mac' :
                 'battlecode-client-linux'

// Tell Gradle to download the game and client.
dependencies {
    compile group: 'org.battlecode', name: 'battlecode', version: '2017.+'
    client group: 'org.battlecode', name: clientName, version: '2017.+'
}

// Eclipse specifc setup to enable docs and sources.
eclipse {
    classpath {
        downloadJavadoc = true
        downloadSources = true
    }
}

// Default configuration for running matches.
if (!project.hasProperty("teamA")) {
    ext.teamA = "examplefuncsplayer"
}
if (!project.hasProperty("teamB")) {
    ext.teamB = "examplefuncsplayer"
}
if (!project.hasProperty("maps")) {
    ext.maps = "shrine"
}

// Here we define a task. Tasks like this one, 'unpackClient', can be
// executed in the terminal with `./gradlew unpackClient` in Unix or
// `gradlew.bat unpackClient` in Windows.
task unpackClient(type: Copy, dependsOn: configurations.client) {
    description 'Downloads the client.'
    group 'battlecode'

    dependsOn configurations.client

    from {
        configurations.client.collect {
            zipTree(it)
        }
    }
    into 'client/'
}

// Another task. This one accepts three optional parameters, or "properties",
// corresponding to the bots used by the two teams, and the map(s) used in this
// game. These properties can be set in the command line with:
// `./gradlew(.bat) -PteamA=<team A bot> -PteamB=<team B bot> -Pmaps=<comma
// separated list of maps>`
task run(type: JavaExec, dependsOn: 'build') {
    description 'Runs a match without starting the client.'
    group 'battlecode'

    main = 'battlecode.server.Main'
    classpath = sourceSets.main.runtimeClasspath
    args = ['-c=-']
    jvmArgs = [
        '-Dbc.server.mode=headless',
        '-Dbc.server.map-path=maps',
        '-Dbc.server.debug=true',
        '-Dbc.engine.debug-methods=true',
        '-Dbc.game.team-a='+project.property('teamA'),
        '-Dbc.game.team-b='+project.property('teamB'),
        '-Dbc.game.team-a.url='+sourceSets.main.output.classesDir,
        '-Dbc.game.team-b.url='+sourceSets.main.output.classesDir,
        '-Dbc.game.maps='+project.property('maps'),
        '-Dbc.server.save-file=' + 'matches/' + project.property('teamA') + '-vs-' + project.property('teamB') + '-on-' + project.property('maps') + '.bc17'
    ]
}

// This task prints out all available players, in the format that the `run`
// task expects them to be given as.
task listPlayers {
    description 'Lists all available players.'
    group 'battlecode'

    doLast {
        sourceSets.main.allJava.each {
            if (it.getName().equals('RobotPlayer.java')) {
                URI base = new File(project.projectDir, 'src').toURI()
                URI full = it.toURI()
                String path = base.relativize(full).toString()
                println 'PLAYER: '+path.substring(0, path.lastIndexOf('/')).replaceAll('/', '.')
            }
        }
    }
}

// This task prints out all available maps, in the format that the `run` task
// expects them to be given as
task listMaps {
    description 'Lists all available maps.'
    group 'battlecode'

    doLast {
        sourceSets.main.compileClasspath.each {
            if (it.toString().contains('battlecode-2017')) {
                FileCollection fc = zipTree(it)
                fc += fileTree(dir: 'matches')
                fc.each {
                    String fn = it.getName()
                    if (fn.endsWith('.map17')) {
                        println 'MAP: '+fn.substring(0, fn.indexOf('.map17'))
                    }
                }
            }
        }
    }
}
